# PRD 기반 상세 구현 추천 사항

`docs/PRD.md`를 바탕으로 프로젝트의 완성도를 높이고 개발 모호성을 줄이기 위한 5가지 추천 사항입니다.

## 1. 수식 파싱 엔진 구체화 및 암시적 곱셈 지원
*   **추천 내용:** `mathjs` 라이브러리를 핵심 파싱 엔진으로 채택하되, 사용자 편의를 위해 **암시적 곱셈(Implicit Multiplication)** 처리를 위한 전처리 로직을 추가할 것을 권장합니다.
*   **이유:** 사용자는 `2*i`보다 `2i` 혹은 `2z`와 같은 입력을 선호합니다. 기본 파서는 이를 변수로 오인하거나 에러를 낼 수 있으므로, 정규표현식 등을 활용한 전처리나 `mathjs` 설정을 통해 자연스러운 수식 입력을 지원해야 UX가 대폭 향상됩니다.

## 2. 그래프 렌더링 라이브러리로 'Mafs' 또는 'Function-plot' 채택
*   **추천 내용:** Raw Canvas API를 직접 다루기보다, 리액트 생태계와 호환성이 좋고 수학적 그래프에 특화된 **Mafs (React)** 또는 **Function-plot** 라이브러리 사용을 추천합니다.
*   **이유:** 줌(Zoom), 팬(Pan), 그리드 렌더링, 반응형 처리가 이미 최적화되어 있어 개발 시간을 단축할 수 있습니다. 특히 `Mafs`는 React 컴포넌트 기반이라 Next.js 환경에서 선언적으로 그래프를 관리하기 매우 적합합니다.

## 3. 고성능 상태 관리를 위한 Zustand 도입
*   **추천 내용:** 입력 패널(Left Panel)과 그래프 캔버스(Right Panel) 간의 빈번한 데이터 동기화를 위해 **Zustand**와 같은 경량 상태 관리 라이브러리 도입을 추천합니다.
*   **이유:** 슬라이더를 움직일 때마다 초당 60프레임으로 그래프가 다시 그려져야 합니다. 불필요한 리렌더링을 방지하고, 특정 값의 변경만 구독(subscribe)하여 성능 저하 없이 매끄러운 애니메이션을 구현하기 위해 효율적인 상태 관리가 필수적입니다.

## 4. 슬라이더 UX 상세 정의 (범위 및 애니메이션 제어)
*   **추천 내용:** 변수 생성 시 슬라이더의 **기본 범위(Default Range)**를 `-10`에서 `10`으로, **Step**을 `0.1` 또는 `0.01`로 설정하고, 사용자가 이 범위를 클릭하여 직접 수정할 수 있는 UI를 포함해야 합니다.
*   **이유:** PRD에 언급된 "실시간 변경" 기능이 유의미하려면 사용자가 보고 싶은 영역을 세밀하게 조정할 수 있어야 합니다. 또한 애니메이션 재생 시 '반복(Loop)', '왕복(Bounce)' 등의 옵션을 제공하면 교육용 도구로서의 가치가 높아집니다.

## 5. 복소평면 모드에서의 극좌표(Polar) 시각화 옵션
*   **추천 내용:** 좌표계 변환 기능에서 단순 라벨(Re/Im vs X/Y) 변경을 넘어, 복소평면 모드일 때는 **극좌표 그리드(원형 그리드)**를 오버레이 할 수 있는 토글 기능을 추가할 것을 제안합니다.
이유: 복소수는 직교좌표(a+bi)뿐만 아니라 극좌표($re^{i\theta}$)로 이해하는 것이 중요합니다. 시각적으로 반지름(Modulus)과 각도(Argument)를 직관적으로 파악할 수 있는 그리드를 제공하면 "복소수 특화 계산기"라는 제품의 정체성을 확실히 할 수 있습니다.

---

## 🚀 다음 단계: 상세 명세화(Specify) 수행

위의 추천 사항들을 반영하여 상세 요구사항 명세서를 생성하려면 아래 명령어를 실행하세요:

```bash
/speckit.specify @docs/PRD.md 및 @docs/recommendation.md의 내용을 바탕으로 복소수 좌표계 그래프 웹사이트의 상세 요구사항 명세서를 작성해줘.
```

---

## 📜 프로젝트 헌법 (Project Constitution)

이 프로젝트의 개발 및 유지보수 과정에서 **AI Agent와 개발자가 반드시 준수해야 할 핵심 원칙**입니다.

### 1. 성능 최적화 (Performance First)
*   **60fps 렌더링 보장:** 슬라이더 조작 시 그래프 갱신은 끊김 없이 부드러워야 합니다. 이를 위해 `React.memo`, `useMemo`, `useCallback`을 적극 활용하고, 불필요한 리렌더링을 유발하는 상태 업데이트를 엄격히 제한합니다.
*   **Transient Update 패턴 적용:** 고빈도 상태 변경(슬라이더 드래그 등)은 리액트의 일반적인 상태 흐름을 우회하거나(예: Refs 활용) `Zustand`의 `subscribe` 기능을 활용하여 캔버스 컴포넌트만 선택적으로 갱신합니다.

### 2. 수학적 정확성 및 예외 처리 (Mathematical Integrity)
*   **검증된 라이브러리 사용:** 복소수 연산 및 파싱은 직접 구현하기보다 `mathjs`와 같은 검증된 라이브러리를 사용합니다.
*   **방어적 코딩:** 0으로 나누기, 무한대 발산(`Infinity`), `NaN` 등의 수학적 예외 상황에서도 앱이 크래시되지 않아야 하며, 사용자에게 시각적으로 적절한 피드백(예: 그래프 렌더링 생략 또는 경고 표시)을 제공해야 합니다.

### 3. 코드 구조 및 타입 안정성 (Structure & Typing)
*   **Strict TypeScript:** `any` 타입 사용을 금지합니다. 수식 파서의 AST(Abstract Syntax Tree) 노드와 상태 객체에 대해 명확한 인터페이스를 정의합니다.
*   **로직과 뷰의 분리:** 수학적 계산 로직(파싱, 평가)은 `hooks`나 `utils`로 분리하고, UI 컴포넌트는 오직 렌더링에만 집중합니다.

### 4. 사용자 경험 중심 (UX Centric)
*   **즉각적인 피드백:** 수식 입력 중 문법 오류가 발생하더라도 전체 앱이 멈추지 않아야 하며, 올바른 수식이 완성되는 즉시 그래프에 반영되어야 합니다.
*   **직관적인 조작:** 줌/팬 조작은 데스크탑(마우스/트랙패드)과 모바일(터치) 환경 모두에서 자연스럽게 동작해야 합니다.
